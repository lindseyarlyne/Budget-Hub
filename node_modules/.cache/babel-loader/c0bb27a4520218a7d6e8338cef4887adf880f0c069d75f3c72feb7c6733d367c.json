{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nexport const useVirtualizer = ({\n  items,\n  itemHeight,\n  containerHeight,\n  overscan = 5\n}) => {\n  _s();\n  const [scrollTop, setScrollTop] = useState(0);\n  const containerRef = useRef(null);\n  const itemRefs = useRef([]);\n\n  // Calculate visible range\n  const visibleRange = useMemo(() => {\n    const start = Math.floor(scrollTop / itemHeight);\n    const visibleCount = Math.ceil(containerHeight / itemHeight);\n    const end = Math.min(start + visibleCount + overscan, items.length);\n    return {\n      start: Math.max(0, start - overscan),\n      end\n    };\n  }, [scrollTop, itemHeight, containerHeight, overscan, items.length]);\n\n  // Get visible items with their positions\n  const visibleItems = useMemo(() => {\n    const result = [];\n    for (let i = visibleRange.start; i < visibleRange.end; i++) {\n      if (items[i]) {\n        result.push({\n          index: i,\n          item: items[i],\n          top: i * itemHeight\n        });\n      }\n    }\n    return result;\n  }, [items, visibleRange, itemHeight]);\n\n  // Handle scroll events with throttling\n  const handleScroll = useCallback(() => {\n    if (containerRef.current) {\n      setScrollTop(containerRef.current.scrollTop);\n    }\n  }, []);\n\n  // Throttled scroll handler for better performance\n  const throttledHandleScroll = useCallback(() => {\n    let ticking = false;\n    return () => {\n      if (!ticking) {\n        requestAnimationFrame(() => {\n          handleScroll();\n          ticking = false;\n        });\n        ticking = true;\n      }\n    };\n  }, [handleScroll]);\n\n  // Scroll to specific index\n  const scrollToIndex = useCallback(index => {\n    if (containerRef.current && index >= 0 && index < items.length) {\n      const scrollTop = index * itemHeight;\n      containerRef.current.scrollTop = scrollTop;\n      setScrollTop(scrollTop);\n    }\n  }, [items.length, itemHeight]);\n\n  // Set up scroll listener\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    const scrollHandler = throttledHandleScroll();\n    container.addEventListener('scroll', scrollHandler, {\n      passive: true\n    });\n    return () => {\n      container.removeEventListener('scroll', scrollHandler);\n    };\n  }, [throttledHandleScroll]);\n\n  // Calculate total height for scrollbar\n  const totalHeight = items.length * itemHeight;\n\n  // Style for the container\n  const containerStyle = useMemo(() => ({\n    height: containerHeight,\n    overflow: 'auto',\n    position: 'relative'\n  }), [containerHeight]);\n\n  // Style for the inner container that creates the scrollable area\n  const innerStyle = useMemo(() => ({\n    height: totalHeight,\n    position: 'relative'\n  }), [totalHeight]);\n  return {\n    containerRef,\n    itemRefs,\n    visibleItems,\n    scrollToIndex,\n    containerStyle,\n    innerStyle,\n    totalHeight\n  };\n};\n_s(useVirtualizer, \"zD41Ha7sK/70+7krsyRSFFAzxVs=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useMemo","useVirtualizer","items","itemHeight","containerHeight","overscan","_s","scrollTop","setScrollTop","containerRef","itemRefs","visibleRange","start","Math","floor","visibleCount","ceil","end","min","length","max","visibleItems","result","i","push","index","item","top","handleScroll","current","throttledHandleScroll","ticking","requestAnimationFrame","scrollToIndex","container","scrollHandler","addEventListener","passive","removeEventListener","totalHeight","containerStyle","height","overflow","position","innerStyle"],"sources":["/workspace/src/hooks/useVirtualizer.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\nexport const useVirtualizer = ({ \n  items, \n  itemHeight, \n  containerHeight, \n  overscan = 5 \n}) => {\n  const [scrollTop, setScrollTop] = useState(0);\n  const containerRef = useRef(null);\n  const itemRefs = useRef([]);\n\n  // Calculate visible range\n  const visibleRange = useMemo(() => {\n    const start = Math.floor(scrollTop / itemHeight);\n    const visibleCount = Math.ceil(containerHeight / itemHeight);\n    const end = Math.min(start + visibleCount + overscan, items.length);\n    \n    return {\n      start: Math.max(0, start - overscan),\n      end\n    };\n  }, [scrollTop, itemHeight, containerHeight, overscan, items.length]);\n\n  // Get visible items with their positions\n  const visibleItems = useMemo(() => {\n    const result = [];\n    for (let i = visibleRange.start; i < visibleRange.end; i++) {\n      if (items[i]) {\n        result.push({\n          index: i,\n          item: items[i],\n          top: i * itemHeight\n        });\n      }\n    }\n    return result;\n  }, [items, visibleRange, itemHeight]);\n\n  // Handle scroll events with throttling\n  const handleScroll = useCallback(() => {\n    if (containerRef.current) {\n      setScrollTop(containerRef.current.scrollTop);\n    }\n  }, []);\n\n  // Throttled scroll handler for better performance\n  const throttledHandleScroll = useCallback(() => {\n    let ticking = false;\n    \n    return () => {\n      if (!ticking) {\n        requestAnimationFrame(() => {\n          handleScroll();\n          ticking = false;\n        });\n        ticking = true;\n      }\n    };\n  }, [handleScroll]);\n\n  // Scroll to specific index\n  const scrollToIndex = useCallback((index) => {\n    if (containerRef.current && index >= 0 && index < items.length) {\n      const scrollTop = index * itemHeight;\n      containerRef.current.scrollTop = scrollTop;\n      setScrollTop(scrollTop);\n    }\n  }, [items.length, itemHeight]);\n\n  // Set up scroll listener\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const scrollHandler = throttledHandleScroll();\n    container.addEventListener('scroll', scrollHandler, { passive: true });\n\n    return () => {\n      container.removeEventListener('scroll', scrollHandler);\n    };\n  }, [throttledHandleScroll]);\n\n  // Calculate total height for scrollbar\n  const totalHeight = items.length * itemHeight;\n\n  // Style for the container\n  const containerStyle = useMemo(() => ({\n    height: containerHeight,\n    overflow: 'auto',\n    position: 'relative'\n  }), [containerHeight]);\n\n  // Style for the inner container that creates the scrollable area\n  const innerStyle = useMemo(() => ({\n    height: totalHeight,\n    position: 'relative'\n  }), [totalHeight]);\n\n  return {\n    containerRef,\n    itemRefs,\n    visibleItems,\n    scrollToIndex,\n    containerStyle,\n    innerStyle,\n    totalHeight\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}