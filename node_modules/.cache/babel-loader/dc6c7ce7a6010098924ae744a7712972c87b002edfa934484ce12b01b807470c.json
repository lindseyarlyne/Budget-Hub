{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useMemo } from 'react';\nexport const useFormValidation = (formData, validationRules) => {\n  _s();\n  const [errors, setErrors] = useState({});\n\n  // Memoized validation function\n  const validateField = useCallback((field, value, rules) => {\n    if (!rules) return null;\n    if (rules.required && (!value || value === '')) {\n      return rules.message || `${field} is required`;\n    }\n    if (value && rules.min && Number(value) < rules.min) {\n      return rules.message || `${field} must be at least ${rules.min}`;\n    }\n    if (value && rules.max && Number(value) > rules.max) {\n      return rules.message || `${field} must be no more than ${rules.max}`;\n    }\n    if (value && rules.minLength && value.length < rules.minLength) {\n      return rules.message || `${field} must be at least ${rules.minLength} characters`;\n    }\n    if (value && rules.maxLength && value.length > rules.maxLength) {\n      return rules.message || `${field} must be no more than ${rules.maxLength} characters`;\n    }\n    if (value && rules.pattern && !rules.pattern.test(value)) {\n      return rules.message || `${field} format is invalid`;\n    }\n    if (value && rules.email && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n      return rules.message || 'Invalid email format';\n    }\n    return null;\n  }, []);\n\n  // Validate all fields\n  const validate = useCallback(() => {\n    const newErrors = {};\n    let isValid = true;\n    Object.keys(validationRules).forEach(field => {\n      const error = validateField(field, formData[field], validationRules[field]);\n      if (error) {\n        newErrors[field] = error;\n        isValid = false;\n      }\n    });\n    setErrors(newErrors);\n    return isValid;\n  }, [formData, validationRules, validateField]);\n\n  // Validate single field (for real-time validation)\n  const validateSingleField = useCallback(field => {\n    const error = validateField(field, formData[field], validationRules[field]);\n    setErrors(prev => ({\n      ...prev,\n      [field]: error\n    }));\n    return !error;\n  }, [formData, validationRules, validateField]);\n\n  // Clear errors\n  const clearErrors = useCallback(() => {\n    setErrors({});\n  }, []);\n\n  // Check if form is valid (memoized)\n  const isValid = useMemo(() => {\n    // Check if all required fields have values and no errors exist\n    const hasErrors = Object.values(errors).some(error => error !== null && error !== '');\n    const hasAllRequiredFields = Object.keys(validationRules).every(field => {\n      const rules = validationRules[field];\n      if (rules.required) {\n        const value = formData[field];\n        return value !== null && value !== undefined && value !== '';\n      }\n      return true;\n    });\n    return !hasErrors && hasAllRequiredFields;\n  }, [errors, formData, validationRules]);\n  return {\n    errors,\n    validate,\n    validateSingleField,\n    clearErrors,\n    isValid\n  };\n};\n_s(useFormValidation, \"kmo1GdS4P95QpTJkCJNVLOGSusI=\");","map":{"version":3,"names":["useState","useCallback","useMemo","useFormValidation","formData","validationRules","_s","errors","setErrors","validateField","field","value","rules","required","message","min","Number","max","minLength","length","maxLength","pattern","test","email","validate","newErrors","isValid","Object","keys","forEach","error","validateSingleField","prev","clearErrors","hasErrors","values","some","hasAllRequiredFields","every","undefined"],"sources":["/workspace/src/hooks/useFormValidation.js"],"sourcesContent":["import { useState, useCallback, useMemo } from 'react';\n\nexport const useFormValidation = (formData, validationRules) => {\n  const [errors, setErrors] = useState({});\n\n  // Memoized validation function\n  const validateField = useCallback((field, value, rules) => {\n    if (!rules) return null;\n\n    if (rules.required && (!value || value === '')) {\n      return rules.message || `${field} is required`;\n    }\n\n    if (value && rules.min && Number(value) < rules.min) {\n      return rules.message || `${field} must be at least ${rules.min}`;\n    }\n\n    if (value && rules.max && Number(value) > rules.max) {\n      return rules.message || `${field} must be no more than ${rules.max}`;\n    }\n\n    if (value && rules.minLength && value.length < rules.minLength) {\n      return rules.message || `${field} must be at least ${rules.minLength} characters`;\n    }\n\n    if (value && rules.maxLength && value.length > rules.maxLength) {\n      return rules.message || `${field} must be no more than ${rules.maxLength} characters`;\n    }\n\n    if (value && rules.pattern && !rules.pattern.test(value)) {\n      return rules.message || `${field} format is invalid`;\n    }\n\n    if (value && rules.email && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n      return rules.message || 'Invalid email format';\n    }\n\n    return null;\n  }, []);\n\n  // Validate all fields\n  const validate = useCallback(() => {\n    const newErrors = {};\n    let isValid = true;\n\n    Object.keys(validationRules).forEach(field => {\n      const error = validateField(field, formData[field], validationRules[field]);\n      if (error) {\n        newErrors[field] = error;\n        isValid = false;\n      }\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  }, [formData, validationRules, validateField]);\n\n  // Validate single field (for real-time validation)\n  const validateSingleField = useCallback((field) => {\n    const error = validateField(field, formData[field], validationRules[field]);\n    setErrors(prev => ({\n      ...prev,\n      [field]: error\n    }));\n    return !error;\n  }, [formData, validationRules, validateField]);\n\n  // Clear errors\n  const clearErrors = useCallback(() => {\n    setErrors({});\n  }, []);\n\n  // Check if form is valid (memoized)\n  const isValid = useMemo(() => {\n    // Check if all required fields have values and no errors exist\n    const hasErrors = Object.values(errors).some(error => error !== null && error !== '');\n    \n    const hasAllRequiredFields = Object.keys(validationRules).every(field => {\n      const rules = validationRules[field];\n      if (rules.required) {\n        const value = formData[field];\n        return value !== null && value !== undefined && value !== '';\n      }\n      return true;\n    });\n\n    return !hasErrors && hasAllRequiredFields;\n  }, [errors, formData, validationRules]);\n\n  return {\n    errors,\n    validate,\n    validateSingleField,\n    clearErrors,\n    isValid\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}